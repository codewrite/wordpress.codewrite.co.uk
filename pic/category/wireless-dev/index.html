<!DOCTYPE html>
<!--[if IE 6]>
<html id="ie6" lang="en-US">
<![endif]-->
<!--[if IE 7]>
<html id="ie7" lang="en-US">
<![endif]-->
<!--[if IE 8]>
<html id="ie8" lang="en-US">
<![endif]-->
<!--[if !(IE 6) | !(IE 7) | !(IE 8)  ]><!-->
<html lang="en-US">
<!--<![endif]-->
<meta http-equiv="content-type" content="text/html;charset=UTF-8" />
<head>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-3695330-4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-3695330-4');
</script>

<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width" />
<title>Wireless Development | PIC Tutorials</title>
<link rel="profile" href="../../../xfn/11.html" />
<link rel="stylesheet" type="text/css" media="all" href="../../wp-content/themes/twentyeleven/style.css" />
<link rel="alternate" type="application/rss+xml" title="PIC Tutorials &raquo; Feed" href="../../feed/" />
<link rel="alternate" type="application/rss+xml" title="PIC Tutorials &raquo; Comments Feed" href="../../comments/feed/" />
<link rel="alternate" type="application/rss+xml" title="PIC Tutorials &raquo; Wireless Development Category Feed" href="feed/" />
<link rel='stylesheet' id='collapseomatic-css-css'  href='../../wp-content/plugins/jquery-collapse-o-matic/light_style00e2.css?ver=1.5.7' type='text/css' media='all' />
<script type='text/javascript' src='../../wp-includes/js/jquery/jqueryc1d8.js?ver=1.11.3'></script>
<script type='text/javascript' src='../../wp-includes/js/jquery/jquery-migrate.min1576.js?ver=1.2.1'></script>
<link rel="stylesheet" href="/cookiealert.css">
<style type="text/css">.recentcomments a{display:inline !important;padding:0 !important;margin:0 !important;}</style>
</head>

<body class="archive category category-wireless-dev category-5 single-author two-column right-sidebar">
<div id="page" class="hfeed">
	<header id="branding" role="banner">
			<hgroup>
				<h1 id="site-title"><span><a href="../../" rel="home">PIC Tutorials</a></span></h1>
				<h2 id="site-description">Electronics and Programming Simplified</h2>
			</hgroup>

						<a href="../../">
									<img src="../../wp-content/uploads/sites/2/2013/07/cropped-header1.png" width="1000" height="288" alt="" />
							</a>
			
			
			<nav id="access" role="navigation">
				<h3 class="assistive-text">Main menu</h3>
								<div class="skip-link"><a class="assistive-text" href="#content">Skip to primary content</a></div>
									<div class="skip-link"><a class="assistive-text" href="#secondary">Skip to secondary content</a></div>
												<div class="menu-main-menu-container"><ul id="menu-main-menu" class="menu"><li id="menu-item-349" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-349"><a href="../../../ham/">Amateur Radio</a></li>
<li id="menu-item-351" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-351"><a href="../../about/">About</a></li>
</ul></div>			</nav><!-- #access -->
	</header><!-- #branding -->


	<div id="main">

		<section id="primary">
			<div id="content" role="main">

			
				<header class="page-header">
					<h1 class="page-title">Category Archives: <span>Wireless Development</span></h1>

					<div class="category-archive-meta"><p>Wireless development and solutions</p>
</div>				</header>

				
								
					
	<article id="post-328" class="post-328 post type-post status-publish format-standard hentry category-wireless-dev">
		<header class="entry-header">
						<h1 class="entry-title"><a href="../../2014/03/13/improved-arduino-wireless-board/" rel="bookmark">Improved Arduino Wireless Board</a></h1>
			
						<div class="entry-meta">
				<span class="sep">Posted on </span><a href="../../2014/03/13/improved-arduino-wireless-board/" title="11:02 am" rel="bookmark"><time class="entry-date" datetime="2014-03-13T11:02:33+00:00">March 13, 2014</time></a><span class="by-author">by </span> <span class="author vcard"><a class="url fn n" href="../../author/jon/" title="View all posts by jon" rel="author">jon</a></span></span>			</div><!-- .entry-meta -->
			
						<div class="comments-link">
				<a href="../../2014/03/13/improved-arduino-wireless-board/#comments">1</a>			</div>
					</header><!-- .entry-header -->

				<div class="entry-content">
			<p>The <a title="Chipkit uC32 Wireless Development Board" href="../../2013/12/11/nrf24l01hw/">wireless Chipkit uC32 board</a> was very cumbersome, so I have made a few changes to it. Like the <a title="Standalone Wireless Board using the nRF24L01" href="../../2014/01/13/nrf24l01-test-board-pcb/">standalone board</a>, I decided to have three switches and three LEDs. I made two boards and they look like this:</p>
<p><a href="../../wp-content/uploads/sites/2/2014/03/wireless_uc32_board1.jpg"><img class="alignnone size-medium wp-image-330" alt="wireless_uc32_board1" src="../../wp-content/uploads/sites/2/2014/03/wireless_uc32_board1-300x168.jpg" width="300" height="168" /></a></p>
<p>They plug into the Chipkit uC32 like this:</p>
<p><a href="../../wp-content/uploads/sites/2/2014/03/wireless_uc32_board2.jpg"><img class="alignnone size-medium wp-image-331" alt="wireless_uc32_board2" src="../../wp-content/uploads/sites/2/2014/03/wireless_uc32_board2-300x168.jpg" width="300" height="168" /></a></p>
<p> <a href="../../2014/03/13/improved-arduino-wireless-board/#more-328" class="more-link">Continue reading <span class="meta-nav">&rarr;</span></a></p>
					</div><!-- .entry-content -->
		
		<footer class="entry-meta">
												<span class="cat-links">
				<span class="entry-utility-prep entry-utility-prep-cat-links">Posted in</span> <a href="index.html" rel="category tag">Wireless Development</a>			</span>
															
| </span>
						<span class="comments-link"><a href="../../2014/03/13/improved-arduino-wireless-board/#comments"><b>1</b> Reply</a></span>
			
					</footer><!-- .entry-meta -->
	</article><!-- #post-328 -->

				
					
	<article id="post-216" class="post-216 post type-post status-publish format-standard hentry category-wireless-dev">
		<header class="entry-header">
						<h1 class="entry-title"><a href="../../2014/01/13/nrf24l01-test-board-pcb/" rel="bookmark">nRF24L01 Test board PCB</a></h1>
			
						<div class="entry-meta">
				<span class="sep">Posted on </span><a href="../../2014/01/13/nrf24l01-test-board-pcb/" title="3:36 pm" rel="bookmark"><time class="entry-date" datetime="2014-01-13T15:36:16+00:00">January 13, 2014</time></a><span class="by-author">by </span> <span class="author vcard"><a class="url fn n" href="../../author/jon/" title="View all posts by jon" rel="author">jon</a></span></span>			</div><!-- .entry-meta -->
			
						<div class="comments-link">
				<a href="../../2014/01/13/nrf24l01-test-board-pcb/#respond"><span class="leave-reply">Reply</span></a>			</div>
					</header><!-- .entry-header -->

				<div class="entry-content">
			<p>Building my nRF24L01 board on stripboard was quite time consuming, so I decided to design a PCB. Having looked into this, I decided that, for what I had in mind, there were two cost effective PCB manufacturers. These were:</p>
<ul>
<li><a style="font-style: normal;" title="OSH Park" href="http://oshpark.com/">OSH Park</a> and</li>
<li><a style="font-style: normal;" title="Seeed Studio PCB Service" href="http://www.seeedstudio.com/service/index.php?r=site/pcbService">Seeed Studio</a></li>
</ul>
<p> <a href="../../2014/01/13/nrf24l01-test-board-pcb/#more-216" class="more-link">Continue reading <span class="meta-nav">&rarr;</span></a></p>
					</div><!-- .entry-content -->
		
		<footer class="entry-meta">
												<span class="cat-links">
				<span class="entry-utility-prep entry-utility-prep-cat-links">Posted in</span> <a href="index.html" rel="category tag">Wireless Development</a>			</span>
															
|			
					</footer><!-- .entry-meta -->
	</article><!-- #post-216 -->

				
					
	<article id="post-186" class="post-186 post type-post status-publish format-standard hentry category-wireless-dev">
		<header class="entry-header">
						<h1 class="entry-title"><a href="../../2013/12/11/nrf24l01hw/" rel="bookmark">nRF24L01 PIC16F1455 and chipKIT uC32 Hardware Configuration</a></h1>
			
						<div class="entry-meta">
				<span class="sep">Posted on </span><a href="../../2013/12/11/nrf24l01hw/" title="4:03 pm" rel="bookmark"><time class="entry-date" datetime="2013-12-11T16:03:50+00:00">December 11, 2013</time></a><span class="by-author">by </span> <span class="author vcard"><a class="url fn n" href="../../author/jon/" title="View all posts by jon" rel="author">jon</a></span></span>			</div><!-- .entry-meta -->
			
						<div class="comments-link">
				<a href="../../2013/12/11/nrf24l01hw/#comments">2</a>			</div>
					</header><!-- .entry-header -->

				<div class="entry-content">
			<p>In order to test the nRF24L01 modules I created the following configurations:</p>
<ol>
<li>uC32 transmitter</li>
<li>uC32 Receiver</li>
<li>PIC16F1455 standalone board</li>
</ol>
<p>I did the uC32 boards first because that was the easiest to develop. I am going to describe the standalone PIC16F1455 board first though, because that is the easiest to understand. It looks like this:</p>
<p><a href="../../wp-content/uploads/sites/2/2013/12/keyfob1_hw.jpg"><img class="alignnone size-medium wp-image-191" alt="keyfob1_hw" src="../../wp-content/uploads/sites/2/2013/12/keyfob1_hw-300x163.jpg" width="300" height="163" /></a></p>
<p>Note: I have created a <a title="nRF24L01 Test Board PCB" href="../../2014/01/13/nrf24l01-test-board-pcb/">PCB vesrion of this using OSH Park</a>.</p>
<p>It consists of a PIC16F1455, 3 switches, 3 LEDs, a CR2032 battery to provide 3V, nRF24L01 connector and PICkit3 connector so we can program the PIC. It uses the PICs XLP mode and consumes about 10uA in standby mode &#8211; so the battery will last about 2 years. When any of the buttons are briefly pressed it will send a message (payload = &#8216;a&#8217;, &#8216;b&#8217; or &#8216;c&#8217;), and then go into receive mode for 1 second, or until a message is received. If a message is received (&#8216;a&#8217;, &#8216;b&#8217; or &#8216;c&#8217;) one of the LEDs is lit for a second. If no message is received, after 1 second all the LEDs are briefly flashed. The board can be made to enter receive mode by pressing and holding the right hand switch for  5 seconds. Since receive mode consumes about 11mA we only stay in this mode for 1 minute. If we were to stay in this mode the battery would be drained in less than a day. I built this for my own use (I&#8217;m waiting for some PCBs from OSHPark), but if you would like to buy or make these yourself then let me know by emailing me at jon (at) codewrite (dot) co (dot) uk. To see a video of these boards in operation <a href="http://youtu.be/5Cua6nhKdN8">click here</a></p>
<p>The uC32 board is connected up to the nRF24L01 using a 400 pin breadboard. There are two variations. One transmits a character and then waits for a reply. This looks like:</p>
<p><a href="../../wp-content/uploads/sites/2/2013/12/uC32_nRF24L01TX.jpg"><img class="alignnone size-medium wp-image-205" alt="uC32_nRF24L01TX" src="../../wp-content/uploads/sites/2/2013/12/uC32_nRF24L01TX-300x212.jpg" width="300" height="212" /></a></p>
<p>The other variant sits in receive mode and re-transmits every valid packet that it receives. That looks like this:</p>
<p><a href="../../wp-content/uploads/sites/2/2013/12/uC32_nRF24L01RX.jpg"><img class="alignnone size-medium wp-image-188" alt="uC32_nRF24L01RX" src="../../wp-content/uploads/sites/2/2013/12/uC32_nRF24L01RX-300x168.jpg" width="300" height="168" /></a></p>
<p><span style="color: #339966;"><em>[By the way, the code for both variants is this same. One I/O pin is pulled either high or low. When the code starts it checks this input and runs either the transmit code or the receive code.]</em></span></p>
<p>In order to connect the nRF24L01 boards to the breadboard we need an adapter. This is because the 2&#215;4 connector can&#8217;t be plugged straight into the breadboard (because of the breadboard&#8217;s terminal and bus strip arrangement). I tried two versions of this:</p>
<p><a href="../../wp-content/uploads/sites/2/2013/12/nRF24L01_adapters.jpg"><img class="alignnone size-medium wp-image-190" alt="nRF24L01_adapters" src="../../wp-content/uploads/sites/2/2013/12/nRF24L01_adapters-300x167.jpg" width="300" height="167" /></a></p>
<p>The one on the right was my first attempt which consisted of replacing the connector, whereas the one on the left is neater and doesn&#8217;t require the nRF24L01 board to be modified. Both can be plugged into the breadboard though.</p>
<p>Again, if you are interested in building one of these yourself, or buying an adapter, let me know at jon (at) codewrite (dot) co (dot) uk, and I&#8217;ll see what I can do. I might create a PCB adapter with switches and LEDs on it, so it can be plugged straight into the uC32 board, but that depends whether I can find the time to do it. Although the uC32 version is more expensive than the standalone PIC board (because we need the uC32 board) advantages of the uC32 version are:</p>
<ol>
<li>It&#8217;s easier to experiment with, using the serial library we can send messages to and from a PC or MAC.</li>
<li>We can sit in receive mode indefinitely making range tests and debugging easier.</li>
</ol>
<p>You can find the circuit diagram and code for these boards <a href="../../2013/12/11/nrf24l01sw/">in the main article</a>.</p>
					</div><!-- .entry-content -->
		
		<footer class="entry-meta">
												<span class="cat-links">
				<span class="entry-utility-prep entry-utility-prep-cat-links">Posted in</span> <a href="index.html" rel="category tag">Wireless Development</a>			</span>
															
| </span>
						<span class="comments-link"><a href="../../2013/12/11/nrf24l01hw/#comments"><b>2</b> Replies</a></span>
			
					</footer><!-- .entry-meta -->
	</article><!-- #post-186 -->

				
					
	<article id="post-177" class="post-177 post type-post status-publish format-standard hentry category-wireless-dev">
		<header class="entry-header">
						<h1 class="entry-title"><a href="../../2013/12/11/nrf24l01sw/" rel="bookmark">Wireless Communication using the nRF24L01 Module</a></h1>
			
						<div class="entry-meta">
				<span class="sep">Posted on </span><a href="../../2013/12/11/nrf24l01sw/" title="1:33 pm" rel="bookmark"><time class="entry-date" datetime="2013-12-11T13:33:20+00:00">December 11, 2013</time></a><span class="by-author">by </span> <span class="author vcard"><a class="url fn n" href="../../author/jon/" title="View all posts by jon" rel="author">jon</a></span></span>			</div><!-- .entry-meta -->
			
						<div class="comments-link">
				<a href="../../2013/12/11/nrf24l01sw/#comments">9</a>			</div>
					</header><!-- .entry-header -->

				<div class="entry-content">
			<p>Wireless communication between devices is very appealing, but designing the hardware and writing the software can seem daunting. There are expensive solutions, but I&#8217;m going to show how to communicate using the nRF24L01 which can be purchased for around 60p (about US $1), or less. The nRF24L01 works in the 2.4GHz band and has a good range; In tests, I have managed 20 &#8211; 30 metres inside though lots of concrete and steel, and over 150 metres outside (line of sight). My top tip for getting a good range is to use the 250kbps rate, and keep the packets short &#8211; for my tests I was using a packet length of 6 bytes:</p>
<table border="1">
<tbody>
<tr>
<td>1. preamble   |</td>
<td>2. Address 1   |</td>
<td>3. Address 2   |</td>
<td>4. Address 3   |</td>
<td>5. payload   |</td>
<td>6. crc</td>
</tr>
</tbody>
</table>
<p>I am going to show how to use the nRF24L01 with PIC16F1455 boards and/or chipKIT uC32 boards. I am not going to say too much about the hardware here, because I think the more difficult issue is getting the software right. Suffice to say that the nRF24L01 has a relatively simple interface, but most of the modules that you get have 2&#215;4 pins which won&#8217;t just plug straight into a uC32 (or Arduino) board. You can see more about the hardware by <a href="../../2013/12/11/nrf24l01hw/">following this link</a>. To keep things simple here, we only need to worry about the circuit, which is as follows:</p>
<p><a href="../../wp-content/uploads/sites/2/2013/12/nRF24L01_PIC16F1455.png"><img class="alignnone size-medium wp-image-159" alt="nRF24L01_PIC16F1455" src="../../wp-content/uploads/sites/2/2013/12/nRF24L01_PIC16F1455-300x143.png" width="300" height="143" /></a></p>
<p>As you can see, there are three switches and three LEDs. Our program is going to be very simple. The nRF24L01 has an auto acknowledgement mode which is supposed to simplify things. Does it? Well maybe, but it certainly doesn&#8217;t make it easier to understand. I wouldn&#8217;t recommend it if you are trying to understand how these modules work and how to use them. So we won&#8217;t be using that. Fairly obviously, we are going to need two modules, one for &#8220;transmit&#8221; and one for &#8220;receive&#8221;. I have used quotes for transmit and receive because actually both modules will be transmitting and receiving. The &#8220;transmitter&#8221; sends a packet when one of the buttons is pressed; It then immediately goes into receive mode and waits for a short amount of time to see if a packet is received. The &#8220;receiver&#8221; is continuously waiting for packets. When a valid packet is received the &#8220;receiver&#8221; goes into transmit mode and re-transmits the packet &#8211; hopefully the &#8220;transmitter&#8221; will receive this and light one of the LEDs. This gives us a visual indication that the packet has completed a round trip to the other transceiver and back again. <a href="../../2013/12/11/nrf24l01hw/">There is more detail about this here</a>.</p>
<p>The source code for the uC32 board looks like this:</p>
<pre>#include &lt;SPI.h&gt;

//Pins
const int csnPin = 7;
const int cePin = 9;
const int irqPin = 8;

//Commands
const byte R_REG = 0x00;
const byte W_REG = 0x20;
const byte RX_PAYLOAD = 0x61;
const byte TX_PAYLOAD = 0xA0;
const byte FLUSH_TX = 0xE1;
const byte FLUSH_RX = 0xE2;
const byte ACTIVATE = 0x50;
const byte R_STATUS = 0xFF;

//Registers
const byte CONFIG = 0x00;
const byte EN_AA = 0x01;
const byte EN_RXADDR = 0x02;
const byte SETUP_AW = 0x03;
const byte SETUP_RETR = 0x04;
const byte RF_CH = 0x05;
const byte RF_SETUP = 0x06;
const byte STATUS = 0x07;
const byte OBSERVE_TX = 0x08;
const byte CD = 0x09;
const byte RX_ADDR_P0 = 0x0A;
const byte RX_ADDR_P1 = 0x0B;
const byte RX_ADDR_P2 = 0x0C;
const byte RX_ADDR_P3 = 0x0D;
const byte RX_ADDR_P4 = 0x0E;
const byte RX_ADDR_P5 = 0x0F;
const byte TX_ADDR = 0x10;
const byte RX_PW_P0 = 0x11;
const byte RX_PW_P1 = 0x12;
const byte RX_PW_P2 = 0x13;
const byte RX_PW_P3 = 0x14;
const byte RX_PW_P4 = 0x15;
const byte RX_PW_P5 = 0x16;
const byte FIFO_STATUS = 0x17;
const byte DYNPD = 0x1C;
const byte FEATURE = 0x1D;

//Data
byte RXTX_ADDR[3] = { 0xB5, 0x23, 0xA5 }; //Randomly chosen address

//Local Helper Function Prototypes
void FlushTXRX();
void WriteRegister(byte reg, byte val);
void WriteAddress(byte reg, byte num, byte* addr);
byte ReadRegister(byte reg);
void WriteCommand(byte command);
void WritePayload(byte num, byte* data);
void ReadPayload(byte num, byte* data);

void nRF_Setup()
{
  // start the SPI library:
  SPI.begin();

  // initalize the  CSN and CE pins:
  pinMode(csnPin, OUTPUT);
  pinMode(cePin, OUTPUT);
  pinMode(irqPin, INPUT);

  digitalWrite(csnPin, HIGH);
  digitalWrite(cePin, LOW);

  // give the nRF24L01 time to set up:
  delay(2);

  WriteRegister(CONFIG, 0x0B);         //1 byte CRC, POWER UP, PRX
  WriteRegister(EN_AA, 0x00);          //Disable auto ack
  WriteRegister(EN_RXADDR, 0x01);      //Enable data pipe 0
  WriteRegister(SETUP_AW, 0x01);       //3 byte address
  WriteRegister(SETUP_RETR, 0x00);     //Retransmit disabled
  WriteRegister(RF_CH, 0x01);          //Randomly chosen RF channel
  WriteRegister(RF_SETUP, 0x26);       //250kbps, 0dBm
  WriteRegister(RX_PW_P0, 0x01);       //RX payload = 1 byte

  WriteAddress(RX_ADDR_P0, 3, RXTX_ADDR);
  WriteAddress(TX_ADDR, 3, RXTX_ADDR);

  FlushTXRX();

  Serial.println("Initialized");
}

void RXMode()
{
  WriteRegister(CONFIG, 0x0B);         //1 byte CRC, POWER UP, PRX
  digitalWrite(cePin, HIGH);
}

void TXMode()
{
  digitalWrite(cePin, LOW);
  WriteRegister(CONFIG, 0x0A);         //1 byte CRC, POWER UP, PTX
}

void PowerDown()
{
  digitalWrite(cePin, LOW);
  WriteRegister(CONFIG, 0);
}

byte RXChar()
{
  byte data;
  ReadPayload(1, &amp;data);
  //Clear status bit
  WriteRegister(STATUS, 0x40);
  return data;
}

void TXChar(byte ch)
{
  WritePayload(1, &amp;ch);

  //Wait for char to be sent
  byte stat;
  do
  {
    stat = ReadStatus();
  } while ((stat &amp; 0x20) == 0);

  //Clear status bit
  WriteRegister(STATUS, 0x20);
}

boolean ReadDataAvailable()
{
  if (digitalRead(cePin) == LOW)
    return false;

  byte stat = ReadStatus();
  return (stat &amp; 0x40) != 0;
}

void DumpRegisters()
{
  for (int i=0; i&lt;10; i++)
  {
    digitalWrite(csnPin, LOW);

    SPI.transfer(R_REG | i);
    // send a value of 0 to read the first byte returned:
    byte result = SPI.transfer(0x00);

    Serial.print("Reg (");
    PrintHex(i, 2);
    Serial.print(") = ");
    PrintHex(result, 2);
    Serial.println();

    digitalWrite(csnPin, HIGH);
  }
  Serial.print("IRQ = ");
  Serial.println(digitalRead(irqPin), DEC);
}

// *************** Helper Methods ***************

void FlushTXRX()
{
  //Clear: data RX ready, data sent TX, Max TX retransmits
  WriteRegister(STATUS, 0x70);
  WriteCommand(FLUSH_RX);
  WriteCommand(FLUSH_TX);
}

void WriteRegister(byte reg, byte val)
{
  digitalWrite(csnPin, LOW);
  SPI.transfer(W_REG | reg);
  SPI.transfer(val);
  digitalWrite(csnPin, HIGH);
}

//Address is 3-5 bytes, LSB first
void WriteAddress(byte reg, byte num, byte* addr)
{
  digitalWrite(csnPin, LOW);
  SPI.transfer(W_REG | reg);
  for (byte i=0; i&lt;num; i++)
    SPI.transfer(addr[i]);
  digitalWrite(csnPin, HIGH);
}

byte ReadRegister(byte reg)
{
  digitalWrite(csnPin, LOW);
  SPI.transfer(R_REG | reg);
  byte val = SPI.transfer(0x00);
  digitalWrite(csnPin, HIGH);
  return val;
}

byte ReadStatus()
{
  digitalWrite(csnPin, LOW);
  byte val = SPI.transfer(R_STATUS);
  digitalWrite(csnPin, HIGH);
  return val;
}

void WriteCommand(byte command)
{
  digitalWrite(csnPin, LOW);
  SPI.transfer(command);
  digitalWrite(csnPin, HIGH);
}

void WritePayload(byte num, byte* data)
{
  digitalWrite(csnPin, LOW);
  SPI.transfer(TX_PAYLOAD);
  for (byte i=0; i&lt;num; i++)
    SPI.transfer(data[i]);
  digitalWrite(csnPin, HIGH);

  digitalWrite(cePin, HIGH);
  for (int i=0; i&lt;100;i++)
    asm("nop");
  digitalWrite(cePin, LOW);
}

void ReadPayload(byte num, byte* data)
{
  digitalWrite(csnPin, LOW);
  SPI.transfer(RX_PAYLOAD);
  for (byte i=0; i&lt;num; i++)
    data[i] = SPI.transfer(0);
  digitalWrite(csnPin, HIGH);
}</pre>
<p>I put the code above in a file called nRF24L01.pde. To use these low-level functions I created  the following functions:</p>
<pre>boolean SendChar(char* args)
{
  boolean charReceived = false;
  TXChar(args[0]);
  RXMode();
  delay(2);
  if (ReadDataAvailable())
  {
    Serial.print("RX = ");
    byte ch = RXChar();
    Serial.println(ch);
    charReceived = true;
  }
  TXMode();
  Serial.println("Char sent");
  return charReceived;
}

void ReceiveChar()
{
  byte ch = RXChar();
  TXMode();
  TXChar(ch);
  RXMode();  
  Serial.print("RX = ");
  Serial.println(ch);
}</pre>
<p>You can see that SendChar() sends a single character, immediately enters receive mode and waits 2 milliseconds to receive the echoed response. Theoretically the packet should be received after 330 microseconds at 250kbps (including the 130uS TX/RX switching time), so 2ms should be more than enough.</p>
<p>ReceiveChar() resends the character sent to it. It should be called in a loop similar to the following:</p>
<pre>  void loop()
  {
    if (ReadDataAvailable())
    {
      ReceiveChar();
    }
  }</pre>
<p>So that&#8217;s the uC32 code, what about the PIC16F1455 code? The code for this is similar, but we have to write our own SPI functions. These look like this:</p>
<pre>/* 
 * File:   spi.h
 */

#ifndef SPI_H
#define	SPI_H

#ifdef	__cplusplus
extern "C" {
#endif

void SPI_init();
BYTE SPI_transfer(BYTE data);

#ifdef	__cplusplus
}
#endif

#endif	/* SPI_H */</pre>
<pre>/* 
 * File:   spi.c
 */

#include 
#include 
#include "spi.h"

void SPI_init()
{
    SSPEN = 0;
    TRISC0 = 0;     //SCK
    ANSC1 = 0;      //SDI
    TRISC2 = 0;     //SDO
    CKE = 1;
    SSPCON1 = 0x01;  //CKP = 0, SCK = 1MHz
    SMP = 1;
    SSPEN = 1;
}

BYTE SPI_transfer(BYTE data)
{
    SSPBUF = data;       // Put command into SPI buffer
    while (!BF);         // Wait for the transfer to finish
    return SSPBUF;       // Save the read value
}</pre>
<p>The settings in SPI_init() are important. CKE, SSPCON1 and SMP determine the SPI timings. If we get these wrong the nRF24L01 won&#8217;t communicate with us reliably. The settings must be: CKE = 1, CKP = 0 and SMP = 1. If you want to know which edges of the waveforms are used then you can work this out from the datasheet, or you can just trust me if I say that these settings work!</p>
<p>The nRF24L01 files are similar to the uC32 ones, with a few modifications:</p>
<pre>/*
 nRF24L01 Header
 */

void nRF_Setup();
void RXMode();
void TXMode();
void PowerDown();
BYTE RXChar();
void TXChar(BYTE ch);
BOOL ReadDataAvailable();
void FlushTXRX();</pre>
<pre>/*
 nRF24L01 Interface
 */

#include 
#include 
#include "spi.h"
#include "nRF24L01.h"

//Pins
#define triscsn TRISA5
#define trisce TRISA4
#define csnPin RA5
#define cePin RA4
//#define irqPin

//Commands
const BYTE R_REG = 0x00;
const BYTE W_REG = 0x20;
const BYTE RX_PAYLOAD = 0x61;
const BYTE TX_PAYLOAD = 0xA0;
const BYTE FLUSH_TX = 0xE1;
const BYTE FLUSH_RX = 0xE2;
const BYTE ACTIVATE = 0x50;
const BYTE R_STATUS = 0xFF;

//Registers
const BYTE NRF_CONFIG = 0x00;
const BYTE EN_AA = 0x01;
const BYTE EN_RXADDR = 0x02;
const BYTE SETUP_AW = 0x03;
const BYTE SETUP_RETR = 0x04;
const BYTE RF_CH = 0x05;
const BYTE RF_SETUP = 0x06;
const BYTE NRF_STATUS = 0x07;
const BYTE OBSERVE_TX = 0x08;
const BYTE CD = 0x09;
const BYTE RX_ADDR_P0 = 0x0A;
const BYTE RX_ADDR_P1 = 0x0B;
const BYTE RX_ADDR_P2 = 0x0C;
const BYTE RX_ADDR_P3 = 0x0D;
const BYTE RX_ADDR_P4 = 0x0E;
const BYTE RX_ADDR_P5 = 0x0F;
const BYTE TX_ADDR = 0x10;
const BYTE RX_PW_P0 = 0x11;
const BYTE RX_PW_P1 = 0x12;
const BYTE RX_PW_P2 = 0x13;
const BYTE RX_PW_P3 = 0x14;
const BYTE RX_PW_P4 = 0x15;
const BYTE RX_PW_P5 = 0x16;
const BYTE FIFO_STATUS = 0x17;
const BYTE DYNPD = 0x1C;
const BYTE FEATURE = 0x1D;

//Data
BYTE RXTX_ADDR[3] = { 0xB5, 0x23, 0xA5 }; //Randomly chosen address
BOOL rfCardPresent = FALSE;

//Local Helper Function Prototypes
void FlushTXRX();
void WriteRegister(BYTE reg, BYTE val);
void WriteAddress(BYTE reg, BYTE num, BYTE* addr);
BYTE ReadRegister(BYTE reg);
BYTE ReadStatus();
void WriteCommand(BYTE command);
void WritePayload(BYTE num, BYTE* data);
void ReadPayload(BYTE num, BYTE* data);

void nRF_Setup()
{
  // start the SPI library:
  SPI_init();

  // initalize the  CSN and CE pins:
  triscsn = 0;
  trisce = 0;

  csnPin = 1;
  cePin = 0;

  WriteRegister(NRF_CONFIG, 0x0B);     //1 BYTE CRC, POWER UP, PRX
  WriteRegister(EN_AA, 0x00);          //Disable auto ack
  WriteRegister(EN_RXADDR, 0x01);      //Enable data pipe 0
  WriteRegister(SETUP_AW, 0x01);       //3 BYTE address
  WriteRegister(SETUP_RETR, 0x00);     //Retransmit disabled
  WriteRegister(RF_CH, 0x01);          //Randomly chosen RF channel
  WriteRegister(RF_SETUP, 0x26);       //250kbps, 0dBm
  WriteRegister(RX_PW_P0, 0x01);       //RX payload = 1 BYTE

  WriteAddress(RX_ADDR_P0, 3, RXTX_ADDR);
  WriteAddress(TX_ADDR, 3, RXTX_ADDR);

  FlushTXRX();

  if ((ReadRegister(NRF_CONFIG) &amp; 0x08) != 0)
      rfCardPresent = TRUE;
}

void RXMode()
{
  WriteRegister(NRF_CONFIG, 0x0B);    //1 BYTE CRC, POWER UP, PRX
  cePin = 1;
  //According to the datasheet we shouldn't bring CSN low
  // within Tpece2csn
  //after setting ce high. Can't see why (or when that would
  // happen though)
  //so comment out the next line.
  //__delay_us(4);    //Tpece2csn
}

void TXMode()
{
  cePin = 0;
  WriteRegister(NRF_CONFIG, 0x0A);      //1 BYTE CRC, POWER UP, PTX
}

void PowerDown()
{
  cePin = 0;
  WriteRegister(NRF_CONFIG, 0);
}

BYTE RXChar()
{
  BYTE data;
  ReadPayload(1, &amp;data);
  //Clear status bit
  WriteRegister(NRF_STATUS, 0x40);
  return data;
}

void TXChar(BYTE ch)
{
  WritePayload(1, &amp;ch);

  if (rfCardPresent)
  {
      //Wait for char to be sent
      BYTE stat;
      do
      {
          stat = ReadStatus();
      } while ((stat &amp; 0x20) == 0);
  }

  //Clear status bit
  WriteRegister(NRF_STATUS, 0x20);
}

BOOL ReadDataAvailable()
{
  BYTE stat = ReadStatus();
  return (stat &amp; 0x40) != 0;
}

void FlushTXRX()
{
  WriteRegister(NRF_STATUS, 0x70);
  WriteCommand(FLUSH_RX);
  WriteCommand(FLUSH_TX);
}

// *************** Helper Methods ***************

void WriteRegister(BYTE reg, BYTE val)
{
  csnPin = 0;
  SPI_transfer(W_REG | reg);
  SPI_transfer(val);
  csnPin = 1;
}

//Address is 3-5 bytes, LSB first
void WriteAddress(BYTE reg, BYTE num, BYTE* addr)
{
  csnPin = 0;
  SPI_transfer(W_REG | reg);
  for (BYTE i=0; i&lt;num; i++)
    SPI_transfer(addr[i]);
  csnPin = 1;
}

BYTE ReadRegister(BYTE reg)
{
  csnPin = 0;
  SPI_transfer(R_REG | reg);
  BYTE val = SPI_transfer(0x00);
  csnPin = 1;
  return val;
}

BYTE ReadStatus()
{
  csnPin = 0;
  BYTE val = SPI_transfer(R_STATUS);
  csnPin = 1;
  return val;
}

void WriteCommand(BYTE command)
{
  csnPin = 0;
  SPI_transfer(command);
  csnPin = 1;
}

void WritePayload(BYTE num, BYTE* data)
{
  csnPin = 0;
  SPI_transfer(TX_PAYLOAD);
  for (BYTE i=0; i&lt;num; i++)
    SPI_transfer(data[i]);
  csnPin = 1;

  cePin = 1;
  __delay_us(12);   //Thce (10us) + a bit (2us)
  cePin = 0;
}

void ReadPayload(BYTE num, BYTE* data)
{
  csnPin = 0;
  SPI_transfer(RX_PAYLOAD);
  for (BYTE i=0; i&lt;num; i++)
    data[i] = SPI_transfer(0);
  csnPin = 1;
}</pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
					</div><!-- .entry-content -->
		
		<footer class="entry-meta">
												<span class="cat-links">
				<span class="entry-utility-prep entry-utility-prep-cat-links">Posted in</span> <a href="index.html" rel="category tag">Wireless Development</a>			</span>
															
| </span>
						<span class="comments-link"><a href="../../2013/12/11/nrf24l01sw/#comments"><b>9</b> Replies</a></span>
			
					</footer><!-- .entry-meta -->
	</article><!-- #post-177 -->

				
				
			
			</div><!-- #content -->
		</section><!-- #primary -->

		<div id="secondary" class="widget-area" role="complementary">
			<aside id="search-2" class="widget widget_search"></aside>		<aside id="recent-posts-2" class="widget widget_recent_entries">		<h3 class="widget-title">Recent Posts</h3>		<ul>
					<li>
				<a href="../../2014/03/14/next-project/">Next Project</a>
						</li>
					<li>
				<a href="../../2014/03/13/improved-arduino-wireless-board/">Improved Arduino Wireless Board</a>
						</li>
					<li>
				<a href="../../2014/01/27/cap-meter-temp-stability/">Capacitance Meter Temperature Sensitivity</a>
						</li>
					<li>
				<a href="../../2014/01/25/capacitance-meter-mk-ii/">Capacitance Meter Mk II</a>
						</li>
					<li>
				<a href="../../2014/01/22/experiments-with-uno-cap-meter/">Experiments with the Arduino Capacitance Meter</a>
						</li>
				</ul>
		</aside><aside id="text-3" class="widget widget_text">			<div class="textwidget"><script async src="../../../pagead/js/f.txt"></script>
<!-- d4def396-a457-4882-90f7-74ec2980bba3 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-6883435305856536"
     data-ad-slot="3063473247"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
		</aside><aside id="recent-comments-2" class="widget widget_recent_comments"><h3 class="widget-title">Recent Comments</h3><ul id="recentcomments"><li class="recentcomments"><span class="comment-author-link">Eric</span> on <a href="../../2014/01/25/capacitance-meter-mk-ii/#comment-1102">Capacitance Meter Mk II</a></li><li class="recentcomments"><span class="comment-author-link">Ravi Shankar</span> on <a href="../../2013/12/11/nrf24l01sw/#comment-1071">Wireless Communication using the nRF24L01 Module</a></li><li class="recentcomments"><span class="comment-author-link">Ehsan</span> on <a href="../../2014/01/21/cap-meter-with-arduino-uno/#comment-990">Capacitance measurement with the Arduino Uno</a></li><li class="recentcomments"><span class="comment-author-link">Ehsan</span> on <a href="../../2014/01/21/cap-meter-with-arduino-uno/#comment-987">Capacitance measurement with the Arduino Uno</a></li><li class="recentcomments"><span class="comment-author-link">Andreas</span> on <a href="../../2014/01/25/capacitance-meter-mk-ii/#comment-929">Capacitance Meter Mk II</a></li></ul></aside><aside id="archives-2" class="widget widget_archive"><h3 class="widget-title">Archives</h3>		<ul>
	<li><a href='../../2014/03/'>March 2014</a></li>
	<li><a href='../../2014/01/'>January 2014</a></li>
	<li><a href='../../2013/12/'>December 2013</a></li>
	<li><a href='../../2013/07/'>July 2013</a></li>
		</ul>
</aside><aside id="categories-2" class="widget widget_categories"><h3 class="widget-title">Categories</h3>		<ul>
	<li class="cat-item cat-item-3"><a href="../general/" title="High level overviews - mainly.">General</a>
</li>
	<li class="cat-item cat-item-2"><a href="../usingmplabx/" title="Everything you need to get you started with the MicroChip MPLABX and a PIC.">Getting Started With MPLABX</a>
</li>
	<li class="cat-item cat-item-4"><a href="../pic-usb-solutions/" >PIC USB Solutions</a>
</li>
	<li class="cat-item cat-item-1"><a href="../uncategorized/" >Uncategorized</a>
</li>
	<li class="cat-item cat-item-5 current-cat"><a href="index.html" title="Wireless development and solutions">Wireless Development</a>
</li>
		</ul>
</aside></div><!-- #secondary .widget-area -->

	</div><!-- #main -->

	<footer id="colophon" role="contentinfo">

			

			</div>
	</footer><!-- #colophon -->
</div><!-- #page -->

<script type='text/javascript'>
var colomatduration = 'fast';
var colomatslideEffect = 'slideFade';
</script><script type='text/javascript' src='../../wp-content/plugins/jquery-collapse-o-matic/js/collapse00e2.js?ver=1.5.7'></script>

  <div class="alert alert-dismissible text-center cookiealert" role="alert">
	<div class="cookiealert-container">
	  Cookies &#x1F36A; We use cookies to ensure you get the best experience on our website. <a
		href="https://cookiesandyou.com/" target="_blank">Learn more</a>
	  <button type="button" class="btn btn-primary btn-sm acceptcookies" aria-label="Close">
		I agree
	  </button>
	</div>
  </div>
  <script src="/cookiealert.js"></script>

</body>

</html>